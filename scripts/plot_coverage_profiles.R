#!/usr/bin/Rscript

#==================#
#   HEADER START   #
#==================#
### Created: Jul 22, 2013
### Modified: Jul 22, 2013
### Author: Alexander Kanitz
### Company: Zavolan Group, Biozentrum, University of Basel
### Version: v1.0
### Adapted from: n/a
### Requirements: rtracklayer, optparse, GenomicRanges
#==================#
### Description: Plots coverage profiles for outputs generated by 'bedtools coverage -d'
### Output: Coverage profile for each target region (argument to -b in 'bedtools coverage -d')
#==================#
#    HEADER END    #
#==================#


#=================#
#   TO DO START   #
#=================#

# Include row subset option (i.e. plot positions 2345..5678 of each region)

#=================#
#    TO DO END    #
#=================#


#==========================#
#   PRE-REQUISITES START   #
#==========================#

#---> LOAD GETOPT LIBRARY <---#
suppressPackageStartupMessages(library("optparse"))

#---> GET SCRIPT NAME <---#
script <- sub("--file=", "", basename(commandArgs(trailingOnly=FALSE)[4]))

#---> COMMAND-LINE ARGUMENTS <---#
## List of allowed/recognized arguments
option_list <- list(
		make_option(c("-p", "--cov_file"), action="store", type="character", default="", help="REQUIRED: Coverage in region(s) of interest", metavar="tab file"),
		make_option(c("-q", "--ref_file"), action="store", type="character", default="", help="Reference coverage in region(s) of interest; REQUIRED if --ref_file_as is provided; will be plotted in the same plot, but with a different color", metavar="tab file"),
		make_option(c("-m", "--cov_file_as"), action="store", type="character", default="", help="Coverage opposite of region(s) of interest; REQUIRED if --ref_file and --ref_file_as are provided; if separate coverage files are available for both strands, this option allows plotting of the coverages of each strand on opposite sides of the x axis in the same plot", metavar="tab file"),
		make_option(c("-n", "--ref_file_as"), action="store", type="character", default="", help="Reference coverage opposite of region(s) of interest; REQUIRED if --ref_file and --cov_file_as are provided; see --ref_file and --cov_file_as for further explanations", metavar="tab file"),
		make_option(c("-g", "--groups"), action="store", type="character", default='Sample|Reference', help="Name/identifier for sample and, if applicable, for the reference; in the latter case, separate string by the pipe '|' character [QUOTED STRING; DEFAULT: 'Sample|Reference']", metavar="quoted string"),
		make_option(c("-f", "--norm_factors"), action="store", type="character", default='1|1', help="Normalization factor for sample and, if applicable, for the reference; in the latter case, separate value by the pipe '|' character [QUOTED NUMBER OR FRACTION STRING; DEFAULT: '1|1']", metavar="quoted number/fraction string"),
		make_option(c("-i", "--ids"), action="store", type="character", default="", help="IDs/names of regions to be plotted; either a string of entries separated by the pipe '|' character OR the filename of a flat text file containing one entry per line with no header (automatic detection); no sanity checks performed on the indicated input file! [QUOTED STRING; DEFAULT: '']", metavar="quoted string"),
		make_option(c("-o", "--prefix"), action="store", type="character", default="./coverage_profile_", help="Output prefix; may include path information [STRING; DEFAULT: './coverage_profile_']", metavar="string"),
		make_option(c("-a", "--aggregate"), action="store_true", default=FALSE, help="Aggregate the coverage data for all regions (or the specified specified with --ids); plotted for each position are the mean coverage fractions of the total coverage in the region; region sizes MUST be equal [DEFAULT: FALSE]"),
		make_option(c("-l", "--scale"), action="store_true", default=FALSE, help="Use the same scale for all regions [DEFAULT: FALSE]"),
		make_option(c("-c", "--center"), action="store_true", default=FALSE, help="Center plots around region midpoints [DEFAULT: FALSE]"),
		make_option(c("-h", "--help"), action="store_true", default=FALSE, help="Show this information and die"),
		make_option(c("-u", "--usage"), action="store_true", dest="help", help="Show this information and die"),
		make_option(c("-v", "--verbose"), action="store_true", default=TRUE, help="Print log messages [DEFAULT]"),
		make_option(c("-s", "--silent"), action="store_false", dest="verbose", help="Shut up!")
)
## Parse command-line arguments
opt_parser <- OptionParser(usage="Usage: %prog [OPTIONS] --cov_file [FILE] (--ref_file [FILE] --cov_file_as [FILE] --ref_file_as [FILE])", option_list = option_list, add_help_option=FALSE, description="\nDescription: Plots coverage profiles from files generated by 'bedtools coverage -d'. A second (e.g. reference) profile can be visualized in the same plot. Coverage of different strands can be considered if separate files exist for the 'antisense' strand. If multiple files (reference, antisense) are passed, these have to result from a 'bedtools coverage -d' analysis in which the same target region file (-b) was used.")
opt <- parse_args(opt_parser)

#---> SET SWITCHES AND EXTRACT VALUES <---#
# Set switches based on the available input files
if ( !(opt$ref_file == "") ) { ref = 1 } else { ref = 0 }
if ( !(opt$cov_file_as == "") ) { as = 1 } else { as = 0 }
if ( !(opt$ref_file_as == "") ) { ref_as = 1 } else { ref_as = 0 }
# Get groups
groups <- unlist(strsplit(opt$groups, split="\\|"))
## Get normalization factors
norm <- unlist(strsplit(opt$norm_factors, split="\\|"))
norm <- unlist(lapply(norm, function(num) {eval(parse(text=num))}))
## Get IDs/names from file or from variable
if ( file.exists(opt$ids) ){
	ids <- as.character(read.delim(opt$ids, header=FALSE)[,1])
} else {
	ids <- unlist(strsplit(opt$ids, split="\\|"))
}

#---> SANITY CHECKS <---#
# Die if any required arguments are missing...
if ( opt$cov_file == "" ) { 
	write("[ERROR] Required argument --cov_file missing!\n\n", stderr())	
	stop(print_help(opt_parser))
}
# Die if any dependent arguments are missing...
if ( !(opt$ref_file_as == "") && opt$ref_file == "" ) { 
	write("[ERROR] Argument --ref_file missing! Required if --ref_file_as is provided.\n\n", stderr())	
	stop(print_help(opt_parser))
}
if ( !(opt$ref_file == "") && !(opt$cov_file_as == "") && opt$ref_file_as == "" ) { 
	write("[ERROR] Argument --ref_file_as missing! Required if --ref_file and --cov_file_as are provided.\n\n", stderr())	
	stop(print_help(opt_parser))
}
if ( !(opt$ref_file == "") && !(opt$ref_file_as == "") && opt$cov_file_as == "" ) { 
	write("[ERROR] Argument --cov_file_as missing! Required if --ref_file and --ref_file_as are provided.\n\n", stderr())	
	stop(print_help(opt_parser))
}
# Die if not enough sample groups are provided
if ( length(groups) == 0 ) { 
	write("[ERROR] Option --groups has no valid argument!\n\n", stderr())	
	stop(print_help(opt_parser))
}
if ( ref == 1 && length(groups) < 2 ) {
	write("[ERROR] The argument to option --groups contains too few entries!\n\n", stderr())	
	stop(print_help(opt_parser))		
}
# Warn if too many sample groups are provided
if ( ref == 0 && length(groups) > 1 ) {
	write("[WARNING] The argument to option --groups contains too many entries! Only the first is used:", stderr())	
	groups <- groups[1]
	write(paste0(groups), stderr())
	write("\n", stderr())
}
if ( ref == 1 && length(groups) > 2 ) {
	write("[WARNING] The argument to option --groups contains too many entries! Only the first two are used:", stderr())	
	groups <- groups[1:2]
	write(paste0(groups), stderr())
	write("\n", stderr())
}
# Die if not enough normalization factors are provided
if ( length(norm) == 0 ) { 
	write("[ERROR] Option --norm_factors has no valid argument!\n\n", stderr())	
	stop(print_help(opt_parser))
}
if ( ref == 1 && length(norm) < 2 ) {
	write("[ERROR] The argument to option --norm_factors contains too few entries!\n\n", stderr())	
	stop(print_help(opt_parser))		
}
# Warn if too many normalization factors are provided
if ( ref == 0 && length(norm) > 1 ) {
	write("[WARNING] The argument to option --norm_factors contains too many entries! Only the first is used:", stderr())	
	norm <- norm[1]
	write(paste0(norm), stderr())
	write("\n", stderr())
}
if ( ref == 1 && length(norm) > 2 ) {
	write("[WARNING] The argument to option --norm_factors contains too many entries! Only the first two are used:", stderr())	
	norm <- norm[1:2]
	write(paste0(norm), stderr())
	write("\n", stderr())
}


#==========================#
#    PRE-REQUISITES END    #
#==========================#


#============================#
#   HELPER FUCNTIONS START   #
#============================#

#---> GENERATE X VALUES <---#
# Function generates x values for plotting, evenly distributed around 0
center_x <- function(no_of_values) {
	seq(-(no_of_values/2)+0.5, (no_of_values/2)-0.5, 1)
}

#---> AGGREGATE COVERAGE DATA <---#
aggr_cov <- function(df) {
	tmp <- aggregate(df$norm, list(df$V4), sum)
	tmp <- merge(df, tmp, by.x=4, by.y=1)
	tmp$fract <- tmp$norm / tmp$x
	tmp$fract[is.nan(tmp$fract)] <- 1/( length(tmp$fract) / length(unique(tmp$V4)) )
	tmp$fract[is.infinite(tmp$fract)] <- 1/( length(tmp$fract) / length(unique(tmp$V4)) )
	pos_med <- aggregate(tmp$fract, list(tmp$V7), mean)
	ids <- rep("Aggregate", nrow(pos_med))
	df <- data.frame(V4=ids, V7=pos_med[,1], norm=pos_med[,2])
}

#============================#
#    HELPER FUCNTIONS END    #
#============================#


#================#
#   MAIN START   #
#================#

#---> START MESSAGE <---#
if ( opt$verbose ) cat("Starting '", script, "'...\n\n", sep="")

#---> LOAD INPUT FILES <---#
# Print status message
if ( opt$verbose ) cat("Loading data...\n", sep="")
## Load files
in_1 <- read.delim(opt$cov_file, header=FALSE)
if (ref) 	{ in_2 <- read.delim(opt$ref_file, header=FALSE) }
if (as) 	{ as_1 <- read.delim(opt$cov_file_as, header=FALSE) }
if (ref_as)	{ as_2 <- read.delim(opt$ref_file_as, header=FALSE) }

#---> VALIDATE INPUT FILES <---#
# Print status message
if ( opt$verbose ) cat("Validating data...\n", sep="")
## Make sure region names in the input files are identical, else issue error and die
if (ref) 	{
	if ( !(in_1$V4 == in_2$V4) || !(in_1$V7 == in_2$V7) ) {
		write("[ERROR] Input files are not compatible!\n\n", stderr())
		stop(print_help(opt_parser))
	}
}
if (as) 	{
	if ( !(in_1$V4 == as_1$V4) || !(in_1$V7 == as_1$V7) ) {
		write("[ERROR] Input files are not compatible!\n\n", stderr())
		stop(print_help(opt_parser))
	}	
}
if (ref_as) {
	if ( !(in_1$V4 == as_2$V4) || !(in_1$V7 == as_2$V7) ) {
		write("[ERROR] Input files are not compatible!\n\n", stderr())
		stop(print_help(opt_parser))
	}	
}

#---> SUBSETTING DATA <---#
## If IDs/names supplied, subset by IDs/names (else use ALL regions)
if ( !(length(ids) == 0) ) {
	in_1 <- subset(in_1, V4 %in% ids)
	if (ref) 	{ in_2 <- subset(in_2, V4 %in% ids) }
	if (as) 	{ as_1 <- subset(as_1, V4 %in% ids) }
	if (ref_as)	{ as_2 <- subset(as_2, V4 %in% ids) }	
	# Issue warning and skip all specified IDs/names that were not found in the data
	skipped <- ids[!ids %in% in_1$V4]
	if ( !(length(skipped) == 0) ) {
		write(paste("[WARNING] The following specified region IDs/names were not found in the data and will be skipped for plotting:"), stderr())
		write(skipped, stderr())
		write("\n", stderr())
	}
}
# Extract unique region names
ids <- unique(as.character(in_1$V4))

#---> NORMALIZE DATA <---#
# Print status message
if ( opt$verbose ) cat("Normalizing data...\n", sep="")
## Load files
in_1$norm <- in_1$V8 * norm[1]
if (ref) 	{ in_2$norm <- in_2$V8 * norm[2] }
if (as) 	{ as_1$norm <- as_1$V8 * norm[1] }
if (ref_as)	{ as_2$norm <- as_2$V8 * norm[2] }

#---> AGGREGATE DATA <---#
if ( opt$verbose && opt$aggregate ) cat("Aggregating data...\n", sep="")
## Aggregate data if --aggregate is set
if ( opt$aggregate ) {
	## Generate vector of all region names in all available files
	reg_names <- as.character(in_1$V4)
	if (ref) 	{ reg_names <- c(reg_names, as.character(in_2$V4)) }
	if (as) 	{ reg_names <- c(reg_names, as.character(as_1$V4)) }
	if (ref_as)	{ reg_names <- c(reg_names, as.character(as_2$V4)) }
	## Die if not all regions have the same size
	if ( length(unique(table(reg_names))) > 1 ) {
		write("[ERROR] Cannot aggregate data! Regions do not all have the same size!\n\n", stderr())
		stop(print_help(opt_parser))		
	}
	## Aggregate...
	in_1 <- aggr_cov(in_1)
	if (ref) 	{ in_2 <- aggr_cov(in_2) }
	if (as) 	{ as_1 <- aggr_cov(as_1) }
	if (ref_as)	{ as_2 <- aggr_cov(as_2) }
	## Set ids variable to 'aggregate' alone
	ids <- "Aggregate"
}

#---> SPLIT DATA FOR PLOTTING <---#
# Print status message
if ( opt$verbose ) cat("Preparing data for plotting...\n", sep="")
## Split files by target region
in_1_st <- split(in_1, in_1$V4)
if (ref) 	{ in_2_st <- split(in_2, in_2$V4) }
if (as) 	{ as_1_st <- split(as_1, as_1$V4) }
if (ref_as)	{ as_2_st <- split(as_2, as_2$V4) }

#---> FIND GLOBAL MINIMUM/MAXIMUM Y VALUES <---#
## Determine global minimum/maximum y values if --scale is set
if (opt$scale) {
	## Max y value
	if ( !ref ) { max_y <- max(in_1$norm) } else {
		max_y <- 1.3 * max(in_1$norm, in_2$norm)
	}
	## Min y value
	if ( !as ) { min_y <- 0 } else { 
		if ( !ref_as ) { min_y <- min(-as_1$norm) } else {
			min_y <- min(-as_1$norm, -as_2$norm)
		}
	}
	# Add room for legend
	max_y <- max_y + (max_y + -min_y) * 0.3
}

## Set x and y axis labeling
if (opt$center) { xlab <- "Position" } else { xlab <- "Position relative to region midpoint" }
ylab = "Coverage"

#---> PLOTTING <---#
# Print status message
if ( opt$verbose ) cat("Generating plots...\n", sep="")
# Plot each region
return <- lapply(ids, function(site) {
			
			## Generate x values (if --center is set: around region midpoint)
			if (opt$center) {
				x <- center_x( nrow( in_1_st[[site]] ) )
			} else {
				x <- seq(1, nrow( in_1_st[[site]] ), 1)
			}
			
			## Set individual minimum/maximum y values if --scale is not set
			if (!opt$scale) {
				## Max y value
				if ( !ref ) { 
					max_y <- max(in_1_st[[site]]$norm)
				} else {
					max_y <- max(in_1_st[[site]]$norm, in_2_st[[site]]$norm)
				}
				## Min y value
				if ( !as ) {
					min_y <- 0
				} else { 
					if ( !ref_as ) {
						min_y <- min(-as_1_st[[site]]$norm)
					} else {
						min_y <- min(-as_1_st[[site]]$norm, -as_2_st[[site]]$norm)
					}
				}
				# Add room for legend
				max_y <- max_y + (max_y + -min_y) * 0.3
			}
			
			# Open PDF driver
			pdf(paste0(opt$prefix, site, "_", length(x), "nt.pdf"))
			
			## Plot...
			plot				(x, in_1_st[[site]]$norm,  col=rgb(1, 0, 0, alpha=0.5), type="l", ylim=c(min_y, max_y), xlab=xlab, ylab=ylab, main=paste0("Region: ", site))
			if (ref)	{ lines	(x, in_2_st[[site]]$norm,  col=rgb(0, 0, 1, alpha=0.5)) }
			if (as)		{ lines	(x, -as_1_st[[site]]$norm, col=rgb(1, 0, 0, alpha=0.5)) }
			if (ref_as)	{ lines	(x, -as_2_st[[site]]$norm, col=rgb(0, 0, 1, alpha=0.5)) }	
			
			# Draw legend
			legend("topright", legend=groups, lty=c(1,1), col=c(rgb(1, 0, 0, alpha=0.5), rgb(0, 0, 1, alpha=0.5)))
			
			# Close PDF driver
			dev.off()
		})

#---> END MESSAGE <---#
if ( opt$verbose ) cat("\nDone.\n")

#================#
#    MAIN END    #
#================#