#!/usr/bin/perl

#=============#
#  HEADER //  #
#=============#
## Created: Oct 8, 2014
## Author: Alexander Kanitz
## Company: Zavolan Group, Biozentrum, University of Basel
## Requirements: Getopt::Long
#=============#
#  // HEADER  #
#=============#


#========================#
#  PRAGMAS & MODULES //  #
#========================#
use strict;
use warnings;
use Getopt::Long;

#========================#
#  // PRAGMAS & MODULES  #
#========================#


#======================#
#  USAGE & VERSION //  #
#======================#
sub usage {
### Returns usage information for current script in a string
<<USAGE;
Usage: $0 [OPTIONS] --overlaps <PATH> --count-table <PATH>

Description: Generates a count table of features based on a table of read-feature overlaps generated
             by 'bedtools intersect' from a BAM alignment and a BED12 feature file. Each read
             contributes at most 1 towards the total count.

Options:
	--overlaps <PATH>       Tabular overlaps file as generated by 'bedtools intersect' (see
	                        'Comments' for details; required).
	--count-table <PATH>    Output file in the following format: feature_name <TAB> count
	                        (required).
	--allow-overlaps        Counts from reads aligning to multiple features are split up between
	                        features (see 'Comments' for details). By default, ambiguous reads do
	                        not contribute to final counts.
	--allow-multi-sites     When '--allow-overlaps' is specified, reads aligning to multiple loci do
	                        also contribute to final counts (see 'Comments' for details).
	--only-feature-id       The input file specified via '--overlaps' only contains the names of
	                        features but not their coordinates.
	--verbose               Print detailed log information to STDERR.
	--usage | --help        Show this screen and exit.
	--version               Show version information and exit.

Comments:
	- This script handles output generated by 'bedtools intersect' via the following call: 'bedtools
	  intersect -bed -wo [-s | -S] [-f <FLOAT>] -abam <BAM> -b <BED12> > <TAB>'. Different calls to
	  'bedtools', particularly the specification of input files other than BAM (reads) and BED12
	  (features) will likely lead to unexpected results.
	- Note that overlaps *MUST* be grouped by read name (QNAME field of the BAM file). Otherwise
	  results will invariably be inaccurate (for performance reasons NO VALIDATION is performed).
	  However, the output generated by 'bedtools intersect' with the call described above and a
	  name-sorted BAM alignments input file will be in an appropriate order ('bedtools' v2.19.1).
	- Note that only one instance of duplicate alignments (same feature and coordinates) is
	  considered.
	- Options '--allow-overlaps' and '--allow-multi-sites' allow fine-grained control of how ambiguity
	  in assigning reads shall be resolved. Amiguity arises whenever a given read intersects with 
	  more than one feature, either at the same locus ("overlapping features") or at different loci 
	  (i.e. different coordinates; "repeat sequences") or both. By default, all reads that cannot be
	  unambiguously assigned to exactly one feature are discarded and do not contribute to total 
	  feature counts.
	- When specifying '--allow-overlaps' but not '--allow-multi-sites', ambiguous reads aligning to just
	  one genomic locus (i.e. overlapping features) will be counted as follows: 
	       rw(feature) = 1 / n(features),
	  where rw(feature) is the read weight of each feature and n(features) is the total number of
	  features intersected by the read. Ambiguous reads aligning to multiple loci are discarded.
	- When specifying '--allow-multi-sites' but not '--allow-overlaps', ambiguous reads aligning to 
	  multiple loci with at most one feature per locus are counted as follows:
	       rw(feature) = l(feature)/l(features),
	  where rw(feature) is the read weight of a given feature, l(feature) is the number of loci
	  annotated for that feature and l(features) is the number of loci annotated for all features in
	  question. Ambiguous reads aligning to overlapping features are discarded.
	- When specifying both '--allow-overlaps' and '--allow-multi-sites', ambiguous reads aligning to 
	  more than one feature and/or loci are counted as follows:
	       rw(feature) = l(feature)/l(features),
	  where rw(feature) is the read weight of a given feature, l(feature) is the number of loci
	  annotated for that feature and l(features) is the number of loci annotated for all features in
	  question. Note that in this case every read contributes to the total counts.    
	- Note that in all cases, each read contributes either 0 (when it is discarded) or 1 to the
	  total feature counts. However, when specifying '--allow-overlaps' and/or '--allow-multi-sites',
	  the final count for a given feature may not be an integer.

Written by Alexander Kanitz, Biozentrum, Univerity of Basel on Oct 8, 2014.
Version 1.0.1 (May 27, 2015)
USAGE
}
#-----------------------#
sub version {
### Returns version information for current script in a string
<<VERSION;
$0 version 1.0.1 (May 27, 2015)
Written by Alexander Kanitz, Biozentrum, Univerity of Basel on Oct 8, 2014.
VERSION
}
#======================#
#  // USAGE & VERSION  #
#======================#


#====================#
#  PARSE OPTIONS //  #
#====================#
#---> OPTIONS VARIABLES <---#
my $overlaps = "";
my $counts = "";
my $allow_ol = 0;
my $allow_ms = 0;
my $only_id = 0;
my $usage = 0;
my $verbose = 0;
my $version = 0;

#---> PARSE / ASSIGN OPTIONS <---#
my $options_result = GetOptions (
	'overlaps=s' => \$overlaps,
	'count-table=s' => \$counts,
	'allow-overlaps' => \$allow_ol,
	'allow-multi-sites' => \$allow_ms,
	'only-feature-id' => \$only_id,
	'usage|help' => \$usage,
	'version' => \$version,
	'verbose' => \$verbose
);

#---> VERIFY OPTIONS <---#
# Print usage information and exit if option parsing was not successful
die &usage unless $options_result;

# Print usage information and exit if --usage or --help were specified
die &usage if $usage;

# Print version information and exit if --version was specified
die &version if $version;

# Print usage information and exit if required arguments are not specified
die "[ERROR] Required argument missing.\nExecution aborted!\n", &usage if ! $overlaps || ! $counts;
#====================#
#  // PARSE OPTIONS  #
#====================#


#===========#
#  MAIN //  #
#===========#
#---> STATUS MESSAGE <---#
print STDERR "Starting '$0'...\n" if $verbose;

#---> MAIN VARIABLES <---#
my $feature_counts_hash_ref;

	#---> BODY <---#

	#---> Count reads per feature <---#
	$feature_counts_hash_ref = &count_reads($overlaps, $allow_ol, $allow_ms, $only_id);

	#---> Print feature count hash <---#
	&write_hash_to_table($feature_counts_hash_ref, "\t", $counts);

#---> STATUS MESSAGE <---#
print STDERR "Done.\n" if $verbose;

#---> PROGRAM EXIT <---#
exit 0;
#===========#
#  // MAIN  #
#===========#


#==================#
#  SUBROUTINES //  #
#==================#
sub count_reads {
## Description: Main subroutine
## Accepts: 1. --overlaps input filename <FILE>; 2. --allow-overlaps flag; 3. --allow-multi-sites flag; 4. --only-feature-id flag
## Returns: Reference to hash of feature counts
## Dependencies: n/a
## Type: Specific

	#---> PASS ARGUMENTS ---#
	my ($overlaps, $allow_ol, $allow_ms, $only_id) = @_;

	#---> STATUS MESSAGE <---#
	print STDERR "Counting reads per feature..." . "\n" if $verbose;

	#---> SUBROUTINE VARIABLES <---#
	my $previous_read_id;
	my %counts;
	my %feat_loci;
	my %loci_feat;
	my $overlapping_features = 0;

	#---> BODY <---#

		#---> Open input filehandle <---#
		open my $fh, "<", $overlaps or die "[ERROR] Could not open file '$overlaps'!\nExecution aborted\n";

		#---> Traverse input file line by line <---#
		while (<$fh>) {

			#---> Process and split line <---#
			chomp;
			my @line = split /\t/;

			#---> Extract coordinates, read and feature IDs <---#
			my $read_id = $line[3];
			my $feature_id = $only_id ? $line[6] : $line[15];
			my $coordinates = join "|", $line[0], $line[1], $line[2];

			#---> Validate input <---#
			die "[ERROR] No read ID found. The file appears to be corrupt.\nExecution aborted." unless $read_id;
			die "[ERROR] No feature ID found. The file appears to be corrupt.\nExecution aborted." unless $feature_id;
			die "[ERROR] No coordinates found. The file appears to be corrupt.\nExecution aborted." unless $coordinates;

			#---> Separate the tasks when a new read ID is encountered from those when the previous one is matched <---#
			if ( defined($previous_read_id) && $read_id ne $previous_read_id ) {

				#---> Set convenience variables <---#
				my @feats = keys %feat_loci;
				my @sites = keys %loci_feat;
				my $feat_sites = 0;
				$feat_sites += scalar keys %$_ for values %feat_loci;

				#---> Add to feature count hash <---#
				# IF there is only one feature...
				if ( @feats == 1 ) {
					# ...add 1 to the total count of the feature
					$counts{$feats[0]}++;
				# ELSE IF there is only one locus, but overlapping features and overlaps are allowed...
				} elsif ( scalar @sites == 1 && $allow_ol ) {
					# ...add 1 divided by the number of features to the total counts of each feature
					$counts{$_} += ( 1 / scalar @feats ) for @feats;			
				# ELSE IF there are multiple loci, overlapping features and both multiple loci and overlaps are allowed...
				} elsif ( $#sites && $allow_ms && $overlapping_features && $allow_ol ) {
					# ...add, for each feature, the fraction of the number of mapped loci for the feature divided by the total sum of mapped loci for all features
					$counts{$_} += ( ( scalar keys %{$feat_loci{$_}} ) / $feat_sites ) for @feats;
				# ELSE IF there are no overlapping features but multiple loci and multiple loci are allowed...
				} elsif ( $#sites && $allow_ms && ! $overlapping_features ) {
					# ...add, for each feature, the fraction of the number of mapped loci for the feature divided by the total sum of mapped loci for all features
					$counts{$_} += ( ( scalar keys %{$feat_loci{$_}} ) / $feat_sites ) for @feats;
				# In all other cases: Do not consider read towards total count
				}

				#---> Reset read-specific variables <---#
				%feat_loci = ();
				%loci_feat = ();
				$overlapping_features = 0;

			}

			#---> Set previous read ID to new read ID <---#
			$previous_read_id = $read_id;

                        #---> Fill hash of hashes (feature -> loci and loci -> feature) <---#   
                        $feat_loci{$feature_id}{$coordinates}++;
                        $loci_feat{$coordinates}{$feature_id}++;

                        #---> Set flag if current coordinates are intersected by more than one feature <---#
                        $overlapping_features = 1 if scalar keys %{$loci_feat{$coordinates}} > 1;

		}

		#---> Account for last read <---#

		#---> Set convenience variables <---#
		my @feats = keys %feat_loci;
		my @sites = keys %loci_feat;
		my $feat_sites = 0;
		$feat_sites += scalar keys %$_ for values %feat_loci;

		#---> Add to feature count hash <---#
		# IF there is only one feature...
		if ( @feats == 1 ) {	
			# ...add 1 to the total count of the feature
			$counts{$feats[0]}++;			
		# ELSE IF there is only one locus, but overlapping features and overlaps are allowed...
		} elsif ( scalar @sites == 1 && $allow_ol ) {
			# ...add 1 divided by the number of features to the total counts of each feature
			$counts{$_} += ( 1 / scalar @feats ) for @feats;
		# ELSE IF there are multiple loci, overlapping features and both multiple loci and overlaps are allowed...
		} elsif ( $#sites && $allow_ms && $overlapping_features && $allow_ol ) {
			# ...add, for each feature, the fraction of the number of mapped loci for the feature divided by the total sum of mapped loci for all features
			$counts{$_} += ( ( scalar keys %{$feat_loci{$_}} ) / $feat_sites ) for @feats;
		# ELSE IF there are no overlapping features but multiple loci and multiple loci are allowed...
		} elsif ( $#sites && $allow_ms && ! $overlapping_features ) {
			# ...add, for each feature, the fraction of the number of mapped loci for the feature divided by the total sum of mapped loci for all features
			$counts{$_} += ( ( scalar keys %{$feat_loci{$_}} ) / $feat_sites ) for @feats;
		# In all other cases: Do not consider read towards total count
		}									     

	#---> STATUS MESSAGE <---#
	print STDERR "Counts computed." . "\n" if $verbose;

	#---> RETURN VALUE <---#
	return \%counts;

}
#-----------------------#
sub write_hash_to_table {
## Description: Writes the contents of a hash to a table of the form: KEY <DELIMITER> VALUE; keys are sorted name
## Accepts: 1. Reference to a hash; 2. Delimiter; 3. output file name (if missing, output is printed to STDOUT)
## Returns: n/a
## Dependencies: n/a
## Type: Generic
	#---> PASS ARGUMENTS ---#
	my ($hash_ref, $delim, $out_file) = @_;

	#---> STATUS MESSAGE <---#
	print STDERR "Writing count table..." . "\n" if $verbose;

	#---> BODY <---#

		#---> Open output filehandle <---#
		if ($out_file) {
			open my $fh, '>', $out_file;
			select $fh;
		}

		#---> Print sorted hash to file <---#
		foreach (sort keys %$hash_ref) {
			print $_, $delim, $hash_ref->{$_}, "\n";
		}

	#---> STATUS MESSAGE <---#
	print STDERR "Count table written." . "\n" if $verbose;

}
#==================#
#  // SUBROUTINES  #
#==================#
