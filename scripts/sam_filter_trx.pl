#!/usr/bin/perl

#==================#
#   HEADER START   #
#==================#
### Name: sam_filter_trx.pl
### Created: Feb 14, 2014
### Author: Alexander Kanitz
### Company: Zavolan Group, Biozentrum, University of Basel
### Requirements: GetOpt::Long
#==================#
#    HEADER END    #
#==================#


#==========================#
#   PRE-REQUISITES START   #
#==========================#
#---> PRAGMAS / PACKAGES <---#
use strict;
use warnings;
use Getopt::Long;

#---> USAGE <---#
my $usage_info = &usage;

#---> OPTIONS / ARGUMENTS <---#
my $usage = '';
my $quiet = '';
my $head = '';
my $in = '';
my $out = '';
my $new_header = '';
my $multi = -1;
my $no_strand_info = 0;
my $mm = '';
my $nm = '';
my $options_result = GetOptions (
	'usage|help' => \$usage,
	'quiet' => \$quiet,
	'print-header' => \$head,
	'new-header=s' => \$new_header,
	'keep-mm:i' => \$multi,
        'no-strand-info' => \$no_strand_info,
	'mm=s' => \$mm,
	'nm=s' => \$nm,
	#-----------------------#
	'in=s' => \$in,
	'out=s' => \$out
);

## Die if command line parsing was not successful or required arguments are missing
die $usage_info if $usage || !$options_result;
die $usage_info if !$in || !$out; 

## Die if indicated files do not exist
die "[ERROR] File '$in' not found.\n$usage_info" unless -e $in;
die "[ERROR] File '$new_header' not found.\n$usage_info" unless $new_header eq "" || -e $new_header;

# Unset $head switch if $new_header is set
$head = 0 if $new_header;

#==========================#
#    PRE-REQUISITES END    #
#==========================#


#================#
#   MAIN START   #
#================#
#---> STATUS MESSAGE <---#
print "Starting '$0'...\n" unless $quiet;

#---> GLOBAL VARIABLES <---#
my %mm;
my %nm;

#---> BODY <---#
my $mm_hash_ref = ( $mm && $multi != 0 ) ? &read_mm($mm, $multi) : \%mm;
my $nm_hash_ref = $nm ? &read_nm($nm) : \%nm;
&filter_sam_trx($in, $out, $mm_hash_ref, $nm_hash_ref, $head, $new_header);

#---> STATUS MESSAGE <---#
print "Done.\n" unless $quiet;

#---> PROGRAM EXIT <---#
exit 0;
#================#
#    MAIN END    #
#================#


#=======================#
#   SUBROUTINES START   #
#=======================#
sub usage {
### Function: Returns usage information for current script
### Accepts: n/a
### Returns: String with usage information
### Type: Specialized
'Usage: perl ./sam_filter_trx.pl [OPTIONS] --in [SAM] --out [SAM]

Description: From a SAM file, first removes duplicate records (defined by identical entries for the fields QNAME, FLAG, RNAME, POS & CIGAR), then all QNAME duplicates except for the one(s) with the shortest edit distance. Finally, unless the --keep-mm is set, all alignments of queries with the same edit distance, but different coordinates ("multimappers") are discarded.

Arguments:
--in [SAM]	Input SAM file sorted by QNAME [Required]
--out [SAM]	Output SAM file [Required]
--print-header	Print header (keep input file header if --new-header not specified)
--new-header [FILE]	Uses file indicated in argument as header
--no-strand-info        Used library preparation protocol does not preserve strand information (if unset, all reads mapping to the opposite strand of annotated transcripts - i.e. the appropriate SAM flag is set - are discarded)
--mm [TAB]	Indicate file of "multimapper" QNAMES and counts (output of sam_filter_gen.pl; format: QNAME /TAB/ number of mappings; one entry per line).
--nm [TAB]	Indicate file of QNAMES and their shortest edit distances (output of sam_filter_gen.pl; format: QNAME /TAB/ edit distance; one entry per line).
--keep-mm [INT]	Keep queries with up to INT different alignments. When no INT is supplied or INT is "0", all alignments are kept for each query. By default, all alignments of "multimappers" are removed.
--usage|help	Show this information and die
--quiet	Shut up!

Notes:
If an argument to --nm is specified, the script requires NM tags (i.e. edit distances) to be present in all records of the input SAM file.
CAUTION: Only marginal validation of the input file type/format performed!

Version 1.1 (2014-10-06)
Written by Alexander Kanitz on 2014-02-17
';
}
#-----------------------#
sub read_mm {
### Function: Reads the --mm file generated by sam_filter_gen.pl (written by Alexander Kanitz) into a hash of SAM QNAMEs and number of mapping locations. The latter can be restricted by the second ($multi) parameter.
### Accepts: 1. File of multimappers (SAM QNAME /tab/ mapping_locations) [TAB]; 2. Max kept mapping locations [INT]: reads with equal or fewer mapping locations are NOT put in hash!
### Returns: n/a
### Dependencies: n/a
### Type: Specialized
	#---> PASS ARGUMENTS ---#
	my ($mm, $multi) = @_;
	
	#---> STATUS MESSAGE <---#
	print STDOUT "Reading multimappers from file '$mm'..." . "\n" unless $quiet;

	#---> SUBROUTINE VARIABLES <---#
	my %mm;
	
	#---> BODY <---#

		#---> Open input and output filehandles <---#
		open MM,  "<", $mm  or die "[ERROR] Could not open file '$mm'!\n";
		
		#---> Traverse non-header lines <---#
		while (my $line = <MM>) {

			#---> QNAMEs and mappings locations to hash <---#
			chomp $line;
			my ($id, $mappings)  = split "\t", $line;
			next if $mappings <= $multi;					# Keep (i.e. do NOT place in hash) reads that map to the allowed number of locations or less
			$mm{$id} = $mappings;
		
		}
		
		#---> Close input and output filehandles <---#
		close MM;

	#---> END BODY <---#
	
	#---> STATUS MESSAGE <---#
	print STDOUT "Multimappers read.\n" unless $quiet;
	
	#---> RETURN VALUE <---#
	return \%mm;
}
#-----------------------#
sub read_nm {
### Function: Reads the --nm file generated by sam_filter_gen.pl (written by Alexander Kanitz) into a hash of SAM QNAMEs and the minimum edit distance.
### Accepts: 1. File of multimappers (SAM QNAME /tab/ mapping_locations) [TAB]
### Returns: n/a
### Dependencies: n/a
### Type: Specialized
	#---> PASS ARGUMENTS ---#
	my $nm = shift;
	
	#---> STATUS MESSAGE <---#
	print STDOUT "Reading edit distances from file '$nm'..." . "\n" unless $quiet;

	#---> SUBROUTINE VARIABLES <---#
	my %nm;
	
	#---> BODY <---#
	
		#---> Open input and output filehandles <---#
		open NM,  "<", $nm  or die "[ERROR] Could not open file '$nm'!\n";
		
		#---> Traverse non-header lines <---#
		while (my $line = <NM>) {

			#---> QNAMEs and edit distances to hash <---#
			chomp $line;
			my ($id, $dist)  = split "\t", $line;
			$nm{$id} = $dist;
		
		}
		
		#---> Close input and output filehandles <---#
		close NM;

	#---> END BODY <---#
	
	#---> STATUS MESSAGE <---#
	print STDOUT "Edit distances read.\n" unless $quiet;
	
	#---> RETURN VALUE <---#
	return \%nm;
}
#-----------------------#
sub filter_sam_trx {
### Function: From a sorted SAM file, first removes duplicate records (i.e. same entry name and coordinates, specifically the fields: QNAME, FLAG, RNAME, POS & CIGAR), then all QNAME duplicates except for the one(s) with the shortest edit distance, then (optionally) all alignments of "multimappers" (same QNAME, same edit distance, but different coordinates).
### Accepts: 1. Input file [FILE|SAM]; 2. Output file [FILE|SAM]; 3. Multimapper switch: 0 = remove multimappers, 1 = keep multimappers; 4. Output file for multimapper IDs/QNAMEs; 5. Header switch: FALSE = do not print header, TRUE = print header; 6. Header file (prepends SAM records in output)
### Returns: n/a
### Dependencies: n/a
### Type: Specialized
	#---> PASS ARGUMENTS ---#
	my ($in, $out, $mm_hash_ref, $nm_hash_ref, $head, $new_header) = @_;
	
	#---> STATUS MESSAGE <---#
	print STDOUT "Filtering SAM file '$in'..." . "\n" unless $quiet;

	#---> SUBROUTINE VARIABLES <---#
	my $regex_header = '^\@[A-Za-z][A-Za-z](\t[A-Za-z][A-Za-z0-9]:[ -~]+)+$';
	my $regex_comment = '/^\@CO\t.*/';
	my $last_line;																										# holds the last line
	my $last_id;																										# holds the last distinct QNAME/read ID
	my @AoH;																											# holds references to hashes containing the field values of the last lines that share the same QNAME/read ID
	my @field_keys = qw/QNAME FLAG RNAME POS MAPQ CIGAR RNEXT PNEXT TLEN SEQ QUAL/;										# holds the bareword keys for the hashes containing field values
	my $final_record = 0;
	
	#---> BODY <---#
	
		#---> Open input and output filehandles <---#
		open IN,  "<", $in  or die "[ERROR] Could not open file '$in'!\n";
		open OUT, ">", $out or die "[ERROR] Could not open file '$out'!\n";
		
		#---> Process header lines (assumed at the top of the file!) <---# 
		while (<IN>) {
			if ( /$regex_header/ || /$regex_comment/ ) {
				print OUT if $head;
			}
			else {	
				$last_line = $_;	
				last;			
			}
		}
	
		#---> Reset filehandle position  <---#
		{
			use bytes;
			seek IN, -length($last_line), 1;
		}
	
		#---> Print header from separate file (if indicated in command line)  <---#	
		if ($new_header) {
			open HEAD, "<", $new_header or die "[ERROR] Could not open file 'new_header'!\n";
				while (<HEAD>) {
					print OUT;				
				}				
			close HEAD;			
		}
		
		#---> Traverse non-header lines <---#
		while (my $line = <IN>) {

			#---> Field values to hash <---#
			chomp $line;
			my @field_values = split "\t", $line;
			die "[ERROR] Input file does not look like a valid SAM file!" unless scalar @field_values >= 11;	# Assert presence of at least 11 fields
			my %fields;
			@fields{@field_keys} = @field_values[0 .. 10];
			foreach (@field_values[11 .. $#field_values]) {
				my ($tag, $value) = split ":", $_, 2;
				$fields{$tag} = $value;
			}
			next if &rc_bit($fields{"FLAG"}) == 1 && ! $no_strand_info;						# Remove reverse complemented alignment if --no-strand-info is not set
			die "[ERROR] Edit distance ('NM tag') missing!" if $nm_hash_ref && not defined $fields{"NM"};		# Assert presence of NM tag
			$fields{"NM"} =~  s/i\:(\d+)/$1/;

			#---> Print line if multimapper and edit distance requirements are met <---#
			next if exists $mm_hash_ref->{$fields{"QNAME"}};
			next if $nm && ! exists $nm_hash_ref->{$fields{"QNAME"}} || $nm_hash_ref->{$fields{"QNAME"}} < $fields{"NM"};
			print OUT $line . "\n";
			
		}
		
		#---> Close input and output filehandles <---#
		close OUT;
		close IN;

	#---> END BODY <---#
	
	#---> STATUS MESSAGE <---#
	print STDOUT "Written filtered SAM file to '$out'.\n" unless $quiet;
	
	#---> RETURN VALUE <---#
	return 0;
}
#-----------------------#
sub rc_bit {
### Function: Extract the 0x10 (sequence reverse complemented) bit of the SAM FLAG field 
### Accepts: 1. SAM FLAG field value
### Returns: Value of 0x10 bit
### Dependencies: n/a
### Type: Generic

        #---> PASS ARGUMENTS ---#       
        my $number = shift;

        #---> SUBROUTINE VARIABLES <---#
        my $bin;
        my $bit;

        #---> BODY <---#

                #---> Convert FLAG from decimal to binary <---#
                $bin = sprintf "%012b", $number;

                #---> Insert corresponding insert for each pair of fragments <---#              
                $bit = substr $bin, -5, 1;

        #---> RETURN VALUE <---#
        return $bit;
}
#=======================#
#    SUBROUTINES END    #
#=======================#
