#!/usr/bin/perl

#######
### AUTHOR INFO & CREATION DATE:
### ----------------------------
### Author:		Alexander Kanitz
### Created: 	03-DEC-2012
### Modified:	18-DEC-2012
#######

#######
### FUNCTION:
### ---------
### The script compares one or more tab-separated value (tsv) files generated by 'bam2tsv.R' to the tsv reference file (generated by Andreas Gruber) for the benchmarking of short read mappers). Each alignment is compared  to the original location in the reference file and designated either "TRUE" (location of alignment identical to original position), "FALSE" (not identical) or "UNMAPPED" (no alignment location).
#######

#######
### ARGUMENTS:
### ----------
### 1. A folder containing the tsv alignment files generated by 'bam2tsv.R'. Note that NO '/' is accepted at the end of the folder.
### 2. The base name of the reference file (include full path if not in the same folder as alignment files).
### 3. A pattern (mind Perl usage of patterns!) indicating which files to process. Note that the files that are to be processed MUST have the file extension '.tsv' which is automatically added and therefore should NOT be included in the pattern. If all '.tsv' files in the folder are to be processed (preferred, as the pattern matching was not tested extensively!), indicate '.*'.
### General Notes: Compare the examples in USAGE for further information.
#######

#######
### OUTPUT:
### -------
### For each processed alignment tsv file, an output file with the extension '.log' will be created in the alignment tsv file directory. It contains: 1. sequence ID, 2. sequence description, 3. identity status (TRUE, FALSE, UNMAPPED) and 4. sequence.
#######

#######
### USAGE:
### ------
### perl /path/to/compare_tsv.pl <reference_file> </path/to/files> <pattern>
### Examples:
### 1. perl ~/compare_tsv.pl ref_file.tab ~/tsv_files .* (compares all files in folder '~/tsv_files' with extension '.tsv' to the reference file in the same folder; script in home directory)
### 2. perl ~/compare_tsv.pl ~/ref/ref_file.tab . ^alignments (compares file 'alignments.tsv' in the current folder to the reference file 'ref_file.tab' in the folder '~/ref/'; script in home directory) 
#######

#######
### OVERVIEW:
### ---------
### A. Pre-requisites
### B. File handling
### C. Reference file processing
### D. Mapping/alignment file processing
### E. Clean-up
#######

### A. Pre-requisites
## Define pragmas, read arguments etc.
## Define used pragmas
use warnings;
use strict;
# Define error message for wrong usage
my $usage = 'Usage: perl /path/to/compare_tsv.pl <reference_file> </path/to/files> <pattern>\n';
## Assign arguments (path, reference file, pattern) to variables
my $ref_file = shift or die "$usage";
my $path = shift or die "$usage";
my $pat = shift or die "$usage";
# Append file extension '.tsv' to pattern
$pat = $pat."\.tsv\$";
# Change working directory to indicated path 
chdir($path);
###

### B. File handling 
### Open indicated directory, traverse files and add to array of mapping data files if pattern matches
# Declare array variable for mapping data files
my @map_files;
# Open indicated directory or die
opendir (DIR, $path) or die $!;
# Push each file in directory that matches the indicated pattern + '.tsv' in array
while (my $file = readdir(DIR)) {
	push (@map_files, $file) if ($file =~ m/$pat/);
}
# Close indicated directory
closedir (DIR);
###

### C. Reference file processing
### Open file, split lines, load into hashes
# Declare hash variables for single and multimappers
my (%single_ref, %single_tmp, %multi_tmp);
# Open reference file handle
open (REF, $ref_file);
while (<REF>) {
	chomp;
	# Split line by tabs
	my @cols = split("\t");
	# Extract ID
	my $id = shift(@cols);
	# Calculate length
	my $len = length($cols[5]);
	## Divide into single and multimapper hashes based on annotation (key = ID; value = rest); intialize temporary hashes with default values ('UNMAPPED' for single, '0' for multimapper hash) 
	unless ($cols[4] =~ m/^MULTIMAPPER/) {
		# Initialize single mapper reference hash (key = ID, value = chromosme TAB strand TAB start position TAB end positon TAB sequence category TAB sequence)
		$single_ref{$id} = join("\t", @cols);
		# Initialize single mapper output hash (key = ID, value = sequence category TAB sequence length TAB 'UNMAPPED')
		$single_tmp{$id} = "$cols[4]\t$len\tUNMAPPED"; 
	}
	else {
		## Extract theoretical number of matches from sequence category
		my $matches = $cols[4];
		$matches =~ s/MULTIMAPPER(.*)TIMES/$1/;
		# Initialize multimapper output hash (key = ID, value = possible matches TAB sequence length TAB '0')
		$multi_tmp{$id} = "$matches\t$len\t0";	
	}
}
# Close reference file handle
close (REF);
# Print status message to STDOUT
print "Read reference file $ref_file to memory.\n";
###

### D. Mapping/alignment file processing
### Traverse through array of files, compare each line of each file with corresponding entry in the reference hashes and write results to output files  
foreach (@map_files) { 
	my $map_file = $_;
	
	## D1. Comparisons/Counts
	# Open file handle that processes mapping data file
	open (MAP, $map_file);
	# Initialize single and multimapper output hashes
	my %single_out = %single_tmp;
	my %multi_out = %multi_tmp;
	# Traverse through mapping data file line by line
	while (<MAP>) {
		chomp;
		# Split line by tabs
		my @cols = split("\t");
		# Extract ID
		my $id_map = shift @cols;
		## Search for ID in single mapper hash; if found, compare to reference
		if (defined $single_ref{$id_map}) {				
			# Split reference hash value by tabs
			my @ref = split("\t", $single_ref{$id_map});
			# Split output hash value by tabs
			my @out = split("\t", $single_out{$id_map});
			## Test whether coordinates exist; if not (i.e. "NA"), do nothing
			if ( ($cols[0] eq "NA") || ($cols[2] eq "NA") ) {
			} 
			## Test whether chromosome and strand information are different and whether distance of alignment start or end positions differ by more than 5 nucleotides from real genomic coordinates; if so, set result to 'FALSE'
			elsif ( ($cols[0] ne $ref[0]) || ($cols[1] ne $ref[1]) || (abs($cols[2] - $ref[2] > 5)) || (abs($cols[3] - $ref[3] > 5)) ) {
				# Disregard 'FALSE' result if a previous alignment for the same ID was found to be 'TRUE' 
				$out[2] = "FALSE" unless $out[2] eq "TRUE";
			}
			## Otherwise set result to 'TRUE'
			else {
				$out[2] = "TRUE";
			}
			# Replace output hash entry 
			$single_out{$id_map} = join("\t", @out);
		}
		## Search for ID in multimapper hash; if found, add 1 to count
		elsif (defined $multi_out{$id_map}) {
			# Split output hash value by tabs
			my @multi = split("\t", $multi_out{$id_map});
			# Increase count
			$multi[2]++;
			# Replace output hash entry
			$multi_out{$id_map} = join("\t", @multi);
		}
		## If ID is not found in either the reference file or multimapper hash, print error message to STDOUT
		else {
			print "ERROR: seqID not found in reference. This should not have happened! Is the reference file intact and complete?\n";
		}
	}
	# Close reference file handle
	close (MAP);
	##
	
	## D2. Write output files 
	## Print single mapper output file
	open (SINGLE, ">$map_file.single");
	while (my ($k,$v) = each %single_out) {
    	print SINGLE "$k\t$v\n";
	}	
	close (SINGLE);
	## Print multimapper output file
	open (MULTI, ">$map_file.multi");
	while (my ($k,$v) = each %multi_out) {
    	print MULTI "$k\t$v\n";
	}
	close (MULTI);
	# Print status message to STDOUT
	print "Alignment file $map_file processed.\n";
	##
}
###

### E. Clean-up
exit;
###