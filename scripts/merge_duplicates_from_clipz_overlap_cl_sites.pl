#!/usr/bin/perl

### Author: Alexander Kanitz
### Created: 06-FEB-2013
### Modified: 07-FEB-2013
### Adapted from: N/A 
### Description: Merges duplicates in files generated by 'clipz_overlaps_cl_sites_bed.pl'; it adds up the total numbers and crosslink scores for duplicate entries and keeps the retains the rank, score and begin and end position of the best crosslink
### Arguments: 1. output file generated by 'clipz_overlaps_cl_sites_bed.pl' (possibly) containing duplicates; 2. name for merged file
### Output: Tab-delimited file containing one row for each target feature and the following columns: feature name, feature chromosome, feature start, feature end, feature strand, start best crosslink, end best crosslink, rank best crosslink, score best crosslink, total crosslink score, number of crosslinks
### Usage: perl ./merge_duplicates_from_clipz_overlap_cl_sites.pl 


### A. Pre-requisites
## Pragmas
use warnings;
use strict;
## Command-line arguments / initialization
my $in_file = "/home/kanitz/Dropbox/Work/Eclipse/general/output/1288_cl_sites_in_exons";#shift;
my $out_file = "/home/kanitz/Dropbox/Work/Eclipse/general/output/1288_cl_sites_in_exons_duplicates_removed";#shift;


### B. Main program 
# Merge duplicate entries in crosslink overlap output file
my $array_ref = &tabMergeDuplicatesByColumnToSortedAoARef($in_file, 1);
# Print merged entries back to file
&printAoARef($array_ref, $out_file);
## Status message
print "Done.\n";
## Exit program
exit;
###


### C. Subroutines
sub tabMergeDuplicatesByColumnToSortedAoARef {
### Accepts: 1. name of tab-delimited output file to process; 2. number of header lines (default: 0); 3. column index of values to merge (default: 1)
### Returns: Reference to array (one line/row per merged value) of arrays (individual elements of that line/row); duplicate entries are merged according to the 'mergeRules' subroutine; the returned array of arrays is sorted according to the merged values in alphabetic; the header lines (if present) are  
### Type: Generic
### Dependencies: mergeRules subroutine (define rules for merging duplicate entries; leave blank to always keep the first entry and remove all duplicates)
	## Pass parameters
	my $in_file = shift;
	my $header = @_ ? shift : 0;
	my $by = @_ ? shift : 1;
	# Decrease $by by 1 to match array indices
	$by--;
	# Declare temporary hash of arrays and results array
	my %HoA;
	my @AoA;
	# Open input file handle
	open IN, $in_file;
	## While there are header lines...
	while ($header) {
		# Decrease header count by 1
		$header--;
		# Read line to dedicated variable
		my $line = <IN>;
		# Remove trailing newline character
		chomp($line);
		# Split header line by tab
		my @header = split /\t/, $line;
		push @AoA, [@header];
	}
	## Traverse through each line of input file
	while (<IN>) {
		# Remove trailing newline character
		chomp;
		# Split line by tabs
		my @line = split /\t/;
		## IF hash %HoA entry with same name (= key) exists...
		if (exists $HoA{$line[$by]}) {
			# Call subrouting defining merging rules
			$HoA{$line[$by]} = &mergeRules($HoA{$line[$by]}, \@line);
		} 
		## ELSE create new hash %HoA entry
		else {
			# Initialize empty array as %HoA value for current name (= key)
			$HoA{$line[$by]} = [];
			# Push line into 
			push $HoA{$line[$by]}, @line;
		}
	}
	# Close input file handle
	close IN;
	## Sort hash values alphanumerically and...
	foreach my $key (sort { $a cmp $b } keys %HoA) {
		# push to @results array
		push @AoA, $HoA{$key};
	} 
	# Screen output
	print "Processed file '$in_file'.\n";
	# Return @AoA reference
	return \@AoA;
}
sub mergeRules {
### Accepts: 1. reference to array containing current/reference value(s); 2. reference to array containing new value(s) 
### Returns: Reference to array with updated values determined by the merging rules
### Type: Specific to merging duplicates from 'clipz_overlap_cl_sites.pl' output
### Dependencies: Called by the generic subroutine 'tabMergeDuplicatesByColumnToSortedAoARef' to apply specific rules governing the merging of duplicate values
	## Pass arguments
	my $ref_array_ref = shift;
	my $new_array_ref = shift;
	## Do comparisons between existing and new entry
	## GENERAL MERGING RULES:
	# Increase total number of crosslinks
	$$ref_array_ref[10] += $$new_array_ref[10];
	# Calculate current total score
	$$ref_array_ref[9] += $$new_array_ref[9];
	## CONDITION-DEPENDENT MERGING RULES:
	## IF rank of new line is lower (i.e. better) than current/previous rank...
	if ($$new_array_ref[7] < $$ref_array_ref[7]) {
		# ...set new start position of best crosslink
		$$ref_array_ref[5] = $$new_array_ref[5];
		# ...set new end position of best crosslink
		$$ref_array_ref[6] = $$new_array_ref[6];
		# ...set new rank of best crosslink
		$$ref_array_ref[7] = $$new_array_ref[7];
		# ...set new score of best crosslink
		$$ref_array_ref[8] = $$new_array_ref[8];
	}
	## IF start coordinate of current exon is lower than current/previous one...
	if ($$new_array_ref[2] < $$ref_array_ref[2]) {
		# ...set to newer, lower value
		$$ref_array_ref[2] = $$new_array_ref[2];
	}
	## IF end coordinate of current exon is higher than current/previous one...
	if ($$new_array_ref[3] > $$ref_array_ref[3]) {
		# ...set to newer, lower value
		$$ref_array_ref[3] = $$new_array_ref[3];
	}
	# Return array reference
	return $ref_array_ref;	
}
sub printAoARef {
### Accepts: 1. array reference; 2. output file name; 3. separator to be used within arrays (default: tab); 4. separator to be used between arrays (default: newline)
### Returns: The referenced array, separated by the specified intra- and interarray separators, is written to the indicated output file 
### Type: Generic
### Dependencies: N/A
	## Pass arguments
	my $AoA_ref = shift;
	my $out_file = shift;
	my $sep_intra = @_ ? shift : "\t";
	my $sep_inter = @_ ? shift : "\n";
	# Open output file handle
	open OUT, ">$out_file";
	## Traverse through each dereferenced HoA value
	foreach my $array_ref (@$AoA_ref) {
		# Print current inner array to output file; array elements are separated by $sep_intra (e.g. tab), different arrays by $sep_inter (e.g. newline)
		print OUT join($sep_intra,@$array_ref) . $sep_inter;
	}
	# Screen output
	print "Output written to file '$out_file'.\n";
	# Close output file handle
	close OUT;
}
###